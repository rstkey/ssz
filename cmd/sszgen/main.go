// ssz: Go Simple Serialize (SSZ) codec library
// Copyright 2024 ssz Authors
// SPDX-License-Identifier: BSD-3-Clause

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

func main() {
	var (
		pkgdir   = flag.String("dir", ".", "input package")
		output   = flag.String("out", "-", "output file (default is stdout)")
		typename = flag.String("type", "", "type to generate methods for")
	)
	flag.Parse()

	cfg := Config{Dir: *pkgdir}
	if len(*typename) > 0 {
		cfg.Types = strings.Split(*typename, ",")
	}
	code, err := cfg.process()
	if err != nil {
		fatal(err)
	}
	if *output == "-" {
		os.Stdout.Write(code)
	} else if err := os.WriteFile(*output, code, 0600); err != nil {
		fatal(err)
	}
}

func fatal(args ...interface{}) {
	fmt.Fprintln(os.Stderr, args...)
	os.Exit(1)
}

type Config struct {
	Dir   string // input package directory
	Types []string
}

// process generates the Go code.
func (cfg *Config) process() ([]byte, error) {
	// Load the ssz library package and the target package to generate into
	pcfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedImports | packages.NeedDeps,
		Dir:  cfg.Dir,
	}
	ps, err := packages.Load(pcfg, sszPkgPath, ".")
	if err != nil {
		return nil, err
	}
	if len(ps) == 0 {
		return nil, fmt.Errorf("no Go package found in %s", cfg.Dir)
	}
	if len(ps) != 2 {
		return nil, fmt.Errorf("at most one package can be processed at the same time")
	}
	packages.PrintErrors(ps)

	// Pick out the library package for interfaces and the target package for types
	var (
		library *types.Package
		target  *types.Package
	)
	for _, p := range ps {
		if len(p.Errors) > 0 {
			return nil, fmt.Errorf("package %s has errors", p.PkgPath)
		}
		if p.PkgPath == sszPkgPath {
			library = p.Types
		} else {
			target = p.Types
		}
	}
	// Parse the package in the context of the ssz library
	parser := newParseContext(library)

	types, err := parser.parsePackage(target, cfg.Types)
	if err != nil {
		return nil, err
	}
	var (
		ctx    = newGenContext(target)
		chunks [][]byte
	)
	for _, typ := range types {
		ret, err := generate(ctx, typ)
		if err != nil {
			return nil, err
		}
		chunks = append(chunks, ret)
	}
	code := bytes.Join(chunks, []byte("\n\n"))

	// Add package and imports definition and format code
	code = append(ctx.header(), code...)
	code, err = format.Source(code)
	if err != nil {
		return nil, err
	}
	// Add build comments.
	// This is done here to avoid processing these lines with gofmt.
	var header bytes.Buffer
	fmt.Fprint(&header, "// Code generated by github.com/karalabe/ssz. DO NOT EDIT.\n\n")
	return append(header.Bytes(), code...), nil
}
